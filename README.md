# Microsoft Entraの説明とフロントエンドとバックエンドの実装サンプル

このリポジトリは、Microsoft Entra（旧称Azure Active Directory、以降、Entra ID）を使用した認証と認可の基本的な概念と、フロントエンド（Webアプリケーション: React + MSAL.js）およびバックエンド（Web APIサーバー: Rust + axum）での実装サンプルを提供します。

フロントエンドは次の機能を実装しています。

* Entra IDを使用したシングルサインオン（SSO）
* Entra IDからMicrosoft Graph（以降、Graph）用アクセストークンの取得と、Microsoft Graph API（以降、Graph API）の呼び出し（ユーザー情報の取得）
* Entra IDからバックエンド用アクセストークンの取得と、バックエンドAPIの呼び出し

バックエンドは次の機能を実装しています。

* ユーザー情報取得APIの提供
  * フロントエンドから送信された、Entra IDが発行したアクセストークンの検証
  * 上記アクセストークンを基に、Entra IDからGraph用アクセストークンを取得し、Graph APIを呼び出す処理（ユーザー情報の取得、OBO: On-Behalf-Ofフロー）

このドキュメントでは、OAuth 2.0、OpenID Connect（以降、OIDC）およびEntra IDについて説明します。

また、上記フロントエンドおよびバックエンドを動作させるために必要となる、具体的なEntra IDの設定手順についても説明します。

> Graph APIは、ユーザーやデバイスを管理するためのRESTful APIであり、Entra IDと連携して動作します。

## OAuth 2.0とOpenID Connect（OIDC）の概要

この章では、Entra IDを理解するための前提知識として、OAuth 2.0およびOIDCの基本的な概念を説明します。

### OAuth 2.0の概要

OAuth 2.0は、IDやパスワードなどのユーザーの資格情報（クレデンシャル）を共有することなく、第三者となるアプリケーションに対してAPIへのアクセス権限を委譲するための規格です。

アクセス権限を与えることを、**認可（Authorization）**と呼びます。

ここで、あるアプリケーション（アプリA）が、別のアプリケーション（アプリB、リソースサーバー）が提供するAPIリソースにアクセスしたいとします。
従来の方式では、アプリAからアプリBにユーザーのクレデンシャルを送信し、アプリBがそれを検証する必要がありました。
この方式では、アプリB側でもユーザーのクレデンシャルを管理する必要があり、情報漏洩のリスクが高くなるという問題があります。

また、権限の範囲や有効期限を柔軟に制御することが難しいという課題もありました。

OAuth 2.0では、ユーザーのクレデンシャルを共有することなく、アプリケーションに対して限定的なアクセス権限を付与する仕組みを提供します。

* ユーザーのクレデンシャルは、認可サーバー（Authorization Server）のみで管理されます
* ユーザーが第三者となるアプリケーションを利用する際、認可サーバーからアクセストークンが発行されます
* アプリケーションは、取得したアクセストークンを用いてリソースサーバーにアクセスします
* アクセストークンには、アクセス権限の範囲（スコープ）や有効期限が含まれます

この仕組みにより、OAuth 2.0には次のような利点があります。

* 第三者となるアプリケーションにユーザーのクレデンシャルを渡す必要がありません
* 第三者となるアプリケーションでクレデンシャルを管理する必要がありません
* アクセス権限の範囲や有効期限を制御できます
* クライアント（フロントエンドやバックエンドなど）とリソースサーバーを疎結合にできます

OAuth 2.0には、以下の主要なコンポーネントが存在します。

* 認可サーバー（Authorization Server）
  クライアントからの要求に基づき、アクセストークンを発行します
* リソースオーナー（Resource Owner）
  リソースサーバーで管理されているリソースの所有者であり、通常はエンドユーザーです
* クライアント（Client）
  APIリソースにアクセスするアプリケーション（フロントエンドやバックエンド）です
* リソースサーバー（Resource Server）
  保護されたリソースを提供するAPIサーバーです

### OpenID Connect（OIDC）の概要

OpenID Connect（OIDC）は、OAuth 2.0を拡張し、ユーザーを**認証（Authentication）**するための規格です。

> OAuth 2.0は認可（Authorization）を目的とした規格であり、ユーザーが誰であるかを識別する仕組みを提供しません。
> 一方、OIDCは認証（Authentication）を目的とし、ユーザーが本人であることを確認するための仕組みを提供します。

OIDCでは、ユーザーが認証に成功すると、IDトークンと呼ばれるJWT（JSON Web Token）形式のトークンが発行されます。
IDトークンには、ユーザーの識別情報（クレーム）が含まれており、これを使用してユーザーを識別できます。

> OAuth 2.0では、アクセストークンが発行され、アクセストークンにはアクセス権限の範囲（スコープ）や有効期限が含まれます。

この仕組みにより、OIDCには次のような利点があります。

* IDトークンによりユーザーを安全に識別できます
* アプリケーションがユーザーのクレデンシャルを管理する必要がありません
* シングルサインオン（SSO: Single Sign-On）を実現しやすくなります

## Microsoft Entraの概要

Microsoft Entra（Entra ID、旧称Azure Active Directory）は、クラウド環境における認証およびアクセス管理を提供するID管理サービスです。
Microsoft 365、Azure、Microsoft GraphをはじめとするMicrosoftの各種サービスは、Entra IDを共通のID基盤として利用しています。

Entra IDは、ユーザーを認証し、その結果をIDトークンとして発行することで、複数のアプリケーション間で安全な認証とシングルサインオン（SSO）を実現します。

また、Entra IDはOAuth 2.0に基づき、アプリケーションに対してアクセストークンを発行することで、APIへのアクセス権限を制御します。

したがって、Entra IDは、OAuth 2.0およびOIDCに基づき、**認証と認可の両方を提供するID基盤**であると言えます。

この仕組みにより、Entra IDには次のような利点があります。

* ユーザーやアプリケーションの管理をEntra IDに一元化できます
* 多要素認証などの高度な認証機能をアプリケーション側で実装する必要がありません
* 認証方式やセキュリティポリシーを統一して管理できます
* シングルサインオン（SSO）を容易に実現できます

### Microsoft Entraの基本的な役割

Entra IDには、以下の主要な役割があります。

* 認証（Authentication）
  * ユーザーが「誰であるか」を確認します
  * パスワード認証、多要素認証（MFA）、証明書認証、FIDO2などを提供します
  * 認証結果をIDトークンとして発行します
* 認可（Authorization）
  * ユーザーやアプリケーションが「何にアクセスできるか」を表現します
  * OAuth 2.0に基づき、アクセストークンを発行します
  * アクセストークンには、スコープ（アクセス権限の範囲）、ロール（役割）、有効期限が含まれます
* アクセス管理
  * アプリケーションへのアクセスを制御します
  * スコープやロールに基づいてアクセスを制御します（RBAC: Role-Based Access Control）
  * ユーザーおよび管理者による同意を管理します

「同意」とは、ユーザーまたは管理者が、アプリケーションに対して特定のAPIや権限へのアクセスを許可することを指します。
ユーザーがアプリケーションに初めてサインインする際、Entra IDの同意画面が表示され、要求されている権限に対して同意を求められます。

「APIのアクセス許可」とは、Entra IDにおける用語であり、アプリケーションがアクセスを要求するAPIと権限（スコープまたはロール）の組み合わせを表します。

#### スコープ

スコープ（Scope）とは、アプリケーションがユーザーの代わりに実行できる操作の範囲を表す概念です。
主にOAuth 2.0およびOIDCにおける「委任されたアクセス」で使用されます。

委任されたアクセスとは、ユーザーが自分の権限の一部をアプリケーションに委ね、ユーザーに代わって操作を実行させる仕組みです。
OAuth 2.0およびOIDCでは、アプリケーション自身が直接ユーザーの権限を持つのではなく、「ユーザーが許可した範囲内でのみ、ユーザーとして振る舞う」という形でアクセスを行います。
この「ユーザーの権限をアプリケーションに委ねる」ことを、「委任」と呼びます。

スコープを指定することで、「このアプリケーションは、どのAPIに対して、どの操作までを許可されているのか」を明確に表現できます。

たとえば、Graph APIにはUser.ReadやMail.Readなどのスコープが存在し、これらのスコープをアプリケーションに付与することで、アプリケーションはユーザーのプロフィール情報の読み取りやメールの読み取りを行うことができます。

#### ロール

ロールとは、ユーザーやアプリケーションが実行できる操作や責務をひとまとまりに定義した概念であり、**認可（Authorization）**を実現するための重要な要素です。
Entra IDでは、ロールをユーザーやアプリケーションに割り当てることで、「誰が」「どの操作を」行えるかを制御します。

ロールは、OAuth 2.0におけるスコープと同様にアクセス制御を行う手段ですが、用途や適用範囲が異なります。

Entra IDには、用途に応じて複数のロールが存在します。

* グローバル管理者
  * Entra ID全体に対する管理権限を持つロールです
* アプリケーション管理者
  * 特定のアプリケーションに対する管理権限を持つロールです
* ユーザー管理者
  * ユーザーアカウントの管理権限を持つロールです

#### スコープとロールの違い

スコープとロールはいずれも認可に使用されますが、目的と使いどころが異なります。

* スコープ
  * ユーザーがアプリケーションに対して許可した操作の範囲を表します
  * 主にフロントエンドアプリケーションやユーザー操作が関与するシナリオで使われます
  * アクセストークンに`scp`クレームとして含まれます
* ロール
  * ユーザーやアプリケーションに割り当てられた役割や責務を表します
  * 主にバックエンドやアプリケーション権限で使われます
  * アクセストークンに`roles`クレームとして含まれます

一般的に、ユーザーの操作に基づく細かな権限制御にはスコープを、業務上の役割やシステム的な権限管理にはロールを使用します。

### Microsoft EntraとOAuth 2.0 / OpenID Connectの関係

Entra IDは、OAuth 2.0およびOIDCに基づいて動作するID管理サービスです。

Entra IDは、次の役割を担います。

* ユーザーやアプリケーションの認証
* スコープやロール、同意の管理
* IDトークンやアクセストークンの発行

Entra IDとOAuth 2.0 / OIDCの関係は以下の通りです。

| OAuth 2.0 / OIDC | Microsoft Entra |
| --- | --- |
| 認証サーバー／IdP（Identity Provider: OIDC） | Entra ID |
| 認可サーバー（Authorization Server: OAuth 2.0） | Entra ID |
| クライアント（フロントエンド、バックエンドなど） | 登録されたアプリケーション |
| スコープ／ロール | 登録されたアプリケーションに対するAPIのアクセス許可 |
| IDトークン | Entra IDが発行するJWT形式のトークン |
| アクセストークン | Entra IDが発行するJWT形式のトークン |
| リソースサーバー（Resource Server） | Entra IDによって保護するAPI（例: Graph API） |

Entra IDは、認証のためにIDトークンを、認可のためのアクセストークンを発行します。
しかし、トークンをどのように解釈し、最終的にアクセスを許可するかの判断は、リソースサーバー（API）側の責務です。
したがって、リソースサーバーは、Entra IDが発行したトークンを**必ず検証**し、トークンに含まれるスコープやロールに基づいてアクセス制御を行う必要があります。

Entra IDが発行するトークンは、Entra IDで管理する秘密鍵で署名されています。
リソースサーバーは、Entra IDから署名に対応する公開鍵（JWK:JSON Web Key）を取得し、トークンを検証します。

## Microsoft Entraの概念

Entra IDにアプリケーションを登録することで、次の情報を管理できます。

* このアプリケーションは何か
  * アプリケーション登録
  * アプリケーションID
  * テナントID
* どのような権限でAPIにアクセスするのか
  * クライアントとリソースAPIの区別
  * APIのアクセス許可
  * APIの公開とスコープ定義
  * 同意
* どのURIに認証結果を返すのか
  * リダイレクトURIの設定

### このアプリケーションは何か

Entra IDでは、認証や認可の対象となるものをすべて「アプリケーション」として扱います。
ここでいうアプリケーションには、フロントエンドアプリ、バックエンド、GraphのようなAPIも含まれます。

Entra IDにアプリケーションを登録すると、「このアプリケーションは何か」を識別するためのアプリケーションIDが発行されます。

#### テナント

テナントとは、Microsoft Entra IDにおける認証および認可の管理単位です。
一般的には、1つの組織や団体が1つのテナントに対応します。

テナントには、その組織に属するユーザー、グループ、アプリケーション、権限設定などがまとめて管理されます。
ユーザー認証は必ず特定のテナントに対して行われ、発行されるアクセストークンやIDトークンも、どのテナントで認証されたかを前提として意味を持ちます。

Microsoft Entraでは、アプリケーション登録も必ずテナントに紐づいて作成されます。
このため、「どのテナントのアプリケーションか」「どのテナントのユーザーがサインインするのか」は、Entra IDにおいて非常に重要な概念です。

#### テナントID

テナントIDは、**アプリケーションが属するEntra IDテナントを識別するためのID**です。
Entra IDはマルチテナント構成を取るため、どのテナントのユーザーやアプリケーションであるかを明示する必要があります。

フロントエンドやバックエンドは、テナントIDを指定することで、どのEntra IDテナントからIDトークンやアクセストークンを取得するかを明確にします。

#### アプリケーションの登録

アプリケーションの登録とは、Entra IDに対して「このアプリケーションを認証および認可の対象として扱う」ことを宣言する操作です。

アプリケーションを登録することで、Entra IDは次のような情報を管理できるようになります。

* このアプリケーションが何者であるか
* どのテナントに属しているか
* IDトークンおよびアクセストークンを発行するための設定は何か

フロントエンドやバックエンドがEntra IDと連携するためには、必ず対応するアプリケーションを登録する必要があります。

#### アプリケーションID

アプリケーションIDは、Entra IDが発行する識別子であり、**アプリケーションを一意に識別するためのID**です。
フロントエンドやバックエンドは、このアプリケーションIDを用いて「自分がどのアプリケーションであるか」をEntra IDに伝えます。
アプリケーションIDは、IDトークンおよびアクセストークンを取得する際に使用されます。

### どのような権限でAPIにアクセスするのか

OAuth 2.0およびOIDCでは、アプリケーションがAPIにアクセスする際の権限を明示的に定義します。
Entra IDでは、「誰が」「どのAPIに」「どの権限で」アクセスするのかに基づいて、アクセストークンを発行します。

#### クライアントとリソースAPIの区別

OAuth 2.0では、アプリケーションは役割によって次の2つに分かれます。

* クライアント
* リソースAPI

クライアントは、アクセストークンを取得してAPIを呼び出すアプリケーションです。
フロントエンドアプリや、外部APIを呼び出すバックエンドがクライアントに該当します。

リソースAPIは、アクセストークンを受け取り、それを検証して保護されたリソースを提供するアプリケーションです。
バックエンドやGraphがリソースAPIに該当します。

Entra IDでは、これらはいずれもアプリケーションとして登録しますが、それぞれに対して発行されるアクセストークンは用途が異なります（[APIのアクセス許可](#apiのアクセス許可)）。

#### APIのアクセス許可

APIのアクセス許可とは、**あるアプリケーションが、別のアプリケーションのAPIに対して要求するアクセストークンの権限を定義するもの**です。

たとえば、次のような関係はすべてAPIのアクセス許可として設定されます。

* フロントエンドがGraph用アクセストークンを要求する
* フロントエンドがバックエンド用アクセストークンを要求する
* バックエンドがGraph用アクセストークンを要求する

この設定により、Entra IDは、どのアプリケーションに、どのAPI向けのアクセストークンを、どの権限で発行するかを判断します。

#### APIの公開とスコープ定義

リソースAPIは、「どのような操作を外部のアプリケーションに許可するか」を定義する必要があります。
Entra IDでは、これをAPIの公開と呼びます。

APIの公開では、次のような情報を定義します。

* APIを一意に識別する識別子（アプリケーション ID URI、`api://{application-id}`など）
* アクセストークンに含めることができるスコープ（`access_as_user`など）

スコープは、アクセストークンに付与される権限の範囲を表す単位です。
クライアントは、このスコープを指定してアクセストークンを要求します。

ここで、アクセストークンに付与される「権限」と表現していますが、`access_as_user`はEntra IDがバックエンド向けに慣例的に用いるスコープ名であり、それ自体が具体的な操作権限を定義しているわけではありません。
Entra IDは、`access_as_user`というスコープを解釈せず、このスコープを指定してアクセストークンを取得できるかどうかのみを判定します。

したがって、`access_as_user`は 「ユーザー文脈でバックエンド向けのアクセストークンを取得した」という事実を示す以上の意味を持っていません。

実際のアクセス制御や業務上の権限制御は、アクセストークンに含まれるクレームを基に、バックエンド側で実装する必要があります。

#### 同意

同意とは、**ユーザーまたは管理者が、アプリケーションに対して要求されたアクセストークンの権限を許可すること**です。

委任されたアクセスの場合、通常はユーザーの同意が求められます。
一方、組織全体に影響する権限やアプリケーション権限の場合は、管理者の同意が必要になります。

同意が行われたスコープのみがアクセストークンに含まれ、APIへのアクセスが許可されます。

### どのURIに認証結果を返すのか

OIDCを利用するフロントエンドアプリでは、認証および同意が完了した後、Entra IDはブラウザを特定のURIへリダイレクトします。
この際、フロントエンドはIDトークンを受け取ります。

### リダイレクトURIの設定

リダイレクトURIとは、**IDトークンを受け取るための戻り先のURI**です。

このURIは、セキュリティ上の理由から、事前にアプリケーションに登録しておく必要があります。
登録されていないURIが指定された場合、Entra IDは認証処理を拒否します。

これにより、IDトークンが意図しない第三者のサイトに送信されることを防ぎます。

## On-Behalf-Of(OBO)フローの概要と位置づけ

### OBOフローとは何か

On-Behalf-Of(OBO)フローは、**フロントエンドが取得したアクセストークンを基に、バックエンドが別のAPI用のアクセストークンを取得するためのOAuth2.0フロー**です。

このフローでは、バックエンドは「ユーザー自身」ではなく、**ユーザーの代理(On-Behalf-Of)**として振る舞い、Entra IDに対してアクセストークンを要求します。

その結果、バックエンドは次の性質を持つアクセストークンを取得できます。

* フロントエンドで認証されたユーザーを示すアクセストークン
* バックエンド自身ではなく、ユーザーが同意した権限に基づいたアクセストークン
* Graphなど、別のリソースAPI向けのアクセストークン

### なぜOBOフローが必要なのか

典型的なWebアプリケーションでは、次のような構成を取ることが多くあります。

* フロントエンドがユーザーを認証する
* フロントエンドがバックエンドを呼び出す
* バックエンドが、ユーザーの情報を取得するためにGraphを呼び出す

このとき、バックエンドがGraphを呼び出す方法として、単純に「バックエンド自身の権限」でアクセストークンを取得してしまうと、次の問題が生じます。

* 実際に操作しているユーザーが誰であるかがGraph側で分からない
* ユーザーごとの権限制御ができない
* すべての処理が「バックエンドの権限」で実行されてしまう

OBOフローを利用することで、**フロントエンドで認証されたユーザーのコンテキストを維持したまま、バックエンドがAPIを呼び出す**ことが可能になります。

### OBOフローとEntra IDの概念との対応関係

OBOフローは、これまで説明してきたEntra IDの概念と次のように対応しています。

#### クライアントとリソースAPIの関係

OBOフローでは、役割が次のように整理されます。

* フロントエンド
  * クライアント
  * バックエンド向けのアクセストークンを取得する
* バックエンド
  * フロントエンドから見るとリソースAPI
  * Graphから見るとクライアント
* Graph
  * リソースAPI

つまり、**バックエンドは「リソースAPI」と「クライアント」の両方の役割を持つアプリケーション**になります。

#### APIのアクセス許可との関係

OBOフローを成立させるためには、次のAPIのアクセス許可が設定されている必要があります。

* フロントエンドがバックエンドにアクセスするためのAPIのアクセス許可
* バックエンドがGraphにアクセスするためのAPIのアクセス許可

これらは、それぞれ独立したAPIのアクセス許可としてEntra IDに登録します。

APIのアクセス許可にGraphを追加した場合、OBOフローでは次の流れが成立します。

1. フロントエンドがバックエンド向けのアクセストークンを取得する
2. フロントエンドがバックエンドへアクセストークンを送信する
3. バックエンドがバックエンド自身を受信者（`aud`）とするアクセストークンを受け取り、クライアントシークレットとそのアクセストークンを提示し、Graph向けのアクセストークンを要求する
4. Entra IDがGraph向けのアクセストークンを発行する
5. バックエンドがGraphを呼び出す

このように、クライアントシークレットとAPIのアクセス許可の両方が揃って初めて、OBOフローによるGraph呼び出しが可能になります。

#### スコープと同意との関係

OBOフローでバックエンドが取得できるアクセストークンは、**フロントエンドでユーザーが同意したスコープの範囲内**に制限されます。
つまり、バックエンドは次の両方を満たす範囲でのみ、アクセストークンを取得できます。

* バックエンドに設定されたAPIのアクセス許可
* 上記アクセス許可に基づき、ユーザーまたは管理者が事前に同意したスコープ

これにより、バックエンドがユーザーの意図しない権限でAPIを呼び出すことを防ぎます。

### OBOフローの位置づけまとめ

OBOフローは、Entra IDにおける次の概念を組み合わせて実現される仕組みです。

* クライアントとリソースAPIの区別
* APIのアクセス許可
* APIの公開とスコープ定義
* 同意
* アクセストークンの委任された利用

このフローにより、**フロントエンドで認証されたユーザーの権限を安全にバックエンドへ委譲し、さらに別のリソースAPIへ伝播させる**ことが可能になります。

## アプリケーションの登録と設定

フロントエンドが、Graph APIおよびバックエンドを呼び出し、バックエンドがフロントエンドからのリクエストに応答し、バックエンドからGraph APIを呼び出す構成を実現するために必要な、Entra IDでのアプリケーション登録と設定手順について説明します。

フロントエンドにバックエンドのAPIを呼び出す許可を設定する関係で、最初にバックエンドのアプリケーション登録を説明し、次にフロントエンドを説明します。

### バックエンドの登録と設定

フロントエンドからバックエンドを呼び出すためには、**バックエンドをEntra IDにアプリケーションとして登録**する必要があります。

Entra IDでは、アクセストークンによって保護されるAPIも「アプリケーション」として扱われます。
そのため、バックエンドは単なるサーバー実装ではなく、**アクセストークンの検証主体となるリソースAPI**として登録します。

バックエンドをアプリケーションとして登録することで、Entra IDは次を管理できるようになります。

* このAPIは何者か
* どのテナントに属するAPIか
* どのクライアントがアクセストークンを要求できるか
* どの権限（スコープまたはロール）でアクセスできるか
* 発行するアクセストークンの受信者（`aud`: audience）は誰か

これにより、バックエンドはEntra IDが発行したアクセストークンによって安全に保護されます。

#### バックエンドの役割

本構成におけるバックエンドの役割は次の通りです。

* フロントエンドから送信されるアクセストークンを検証する
* アクセストークンの内容に基づいてリクエストを認可する
* OBOフローを用いてGraph APIを呼び出す

このため、バックエンドは次の2つの立場を持ちます。

* フロントエンドから見るとリソースAPI
* Graphから見るとクライアント

#### アプリケーションID

バックエンドを登録すると、アプリケーションIDが発行されます。
このアプリケーションIDは、**バックエンドを一意に識別するためのID**です。

フロントエンドがバックエンド用のアクセストークンを要求する際、このアプリケーションIDが受信者（`aud`）として使用されます。
そのため、バックエンドは、受信したアクセストークンのaudがこのアプリケーションIDであることを検証します。

#### クライアントシークレット

##### クライアントシークレットとは

クライアントシークレットは、**バックエンドがEntra IDに対して自身を認証するための資格情報**です。
バックエンドは、OBOフローにおいて次の役割を持ちます。

* フロントエンドから受信したアクセストークンをEntra IDに提示する
* Graph向けの新しいアクセストークンを要求する

このとき、Entra IDは「この要求を送信しているのが正当なバックエンドか」を確認する必要があります。
その確認に使用されるのが、クライアントシークレットです。

クライアントシークレットは、秘匿すべき情報であるため、バックエンドの安全な場所に保存し、第三者に漏洩しないように管理する必要があります。

##### なぜクライアントシークレットが必要なのか

OBOフローでは、次の2つが同時に行われます。

* ユーザーの委任された権限を引き継ぐ
* バックエンド自身がクライアントとして認証される

そのため、バックエンドは以下を満たす必要があります。

* ユーザーのアクセストークンを保持していること
* 自身がEntra IDに登録されたアプリケーションであることを証明できること

クライアントシークレットは、後者を満たすために必須です。

##### クライアントシークレットの追加

バックエンドのアプリケーション登録画面で、次の手順を行います。

1. 「証明書とシークレット」を開く
2. 「新しいクライアントシークレット」を追加する
3. 有効期限を設定する
4. 発行されたシークレットの値（シークレットIDではなく）を安全な場所に保存する

このシークレットの値は、一度しか表示されないため、必ず控えておく必要があります。

#### APIのアクセス許可

APIのアクセス許可は、バックエンドがGraph APIを呼び出すためのアクセストークンを取得する際に、要求してよいスコープを指定するために追加します。

APIのアクセス許可は、バックエンドのアプリケーション登録画面で、次の手順を行います。

1. 「APIのアクセス許可」を開く
2. 「アクセス許可の追加」を選択する
3. 「Microsoft Graph」を選択する
4. 「委任されたアクセス許可」を選択する
5. User.Readなど、必要なスコープを追加する

権限を追加した後、テナントの設定によっては管理者の同意が必要になります。

#### APIの公開

バックエンドは、フロントエンドなどの外部のアプリケーションに対してどの操作を許可するかを定義する必要があります。
Entra IDでは、これを「APIの公開」と呼びます。

APIの公開では、次の内容を確認および設定します。

* アプリケーション ID URI: APIを一意に識別する識別子（`api://{backend-application-id}`）
* アクセストークンに含めるスコープ

この設定により、バックエンドは「どの権限を持つアクセストークンであればアクセスを許可するか」を明確にできます。

##### スコープの追加

スコープは、**フロントエンドがバックエンドに対して実行できる操作の範囲**を表します。

このバックエンド用のアプリケーションには、`access_as_user`という名前のスコープを追加します。
「同意できるのは誰ですか?」という項目では、「管理者とユーザー」を指定します。

これらのスコープは、後続のフロントエンドのアプリケーション登録において、APIのアクセス許可として指定されます。

> **同意できるのは誰ですか?**
>
> APIの公開でスコープを追加するとき「管理者とユーザー」と「管理者のみ」のどちらが同意できるか指定できます。
>
> 「管理者とユーザー」を指定した場合、ユーザーがサインイン時にそのスコープへの同意ができます。
> 「管理者とユーザー」は、ユーザーが自分のデータを扱うことを、ユーザーごとに、ユーザー自身の意志で同意できる場合に選択します。
>
> 一方、「管理者のみ」を指定した場合、Entra IDの管理者が同意しない限りそのスコープを使用できません。
> 「管理者のみ」は、組織内のすべてのデータにアクセスする場合や、OBOを経由しないでユーザーとは無関係にAPIを実行する場合に選択します。

### フロントエンドの登録と設定

ユーザーがサインインし、Graph APIおよびバックエンドを呼び出すフロントエンド、Entra IDに登録して設定する方法を説明します。
フロントエンドはOAuth 2.0およびOIDCを利用し、Entra IDからIDトークンおよびアクセストークンを取得します。

フロントエンドをアプリケーションとして登録することで、Entra IDは次の情報を管理できるようになります。

* このフロントエンドアプリケーションは何か
* どのテナントに属しているか
* どのAPIに、どの権限でアクセスできるか
* 認証結果をどのURIに返すか

登録後、フロントエンドにはアプリケーションIDが発行されます。
フロントエンドは、このアプリケーションIDを用いて、自身を識別しながらEntra IDに認証要求を行います。

#### リダイレクトURI

Entra IDで認証を受けた後に、フロントエンドにリダイレクトするURIを指定します。
フロントエンドへリダイレクトするとき、Entra IDはIDトークンを渡します。

##### リダイレクトURIの追加

フロントエンドのアプリケーション登録画面で、次の手順を行います。

1. 「認証」を開く
2. 「リダイレクトURIを追加するプラットフォーム」で「シングルページアプリケーション(SPA)」を選択する
3. リダイレクトURIに、Entra IDの認証ページからリダイレクトさせたいフロントエンドのURIを入力する

#### APIのアクセス許可

フロントエンドは、次の2種類のAPIを呼び出します。

* Graph API
* バックエンド

このため、それぞれに対応するAPIのアクセス許可を設定します。

##### Microsoft Graph APIへのアクセス許可

フロントエンドがGraph APIを呼び出すためには、Graph API向けのアクセストークンが必要です。

APIのアクセス許可として、Graphを追加し、必要なスコープ（例: User.Read）を選択します。
これにより、フロントエンドはGraph API向けアクセストークンを取得できるようになります。

フロントエンドのアプリケーション登録画面で、次の手順を行います。

1. 「APIのアクセス許可」を開く
2. 「アクセス許可の追加」を選択する
3. 「Microsoft Graph」を選択する
4. 「委任されたアクセス許可」を選択する
5. 「アクセス許可」で「User.Read」など、必要なスコープを追加する

#### バックエンドへのアクセス許可

フロントエンドがバックエンドを呼び出すためには、バックエンド向けのアクセストークンが必要です。

バックエンドでは、APIの公開でスコープ（例: access_as_user）が定義されています。
フロントエンドでは、そのスコープをAPIのアクセス許可として追加します。
これにより、フロントエンドは次のようなアクセストークンを要求できるようになります。

フロントエンドのアプリケーション登録画面で、次の手順を行います。

1. 「APIのアクセス許可」を開く
2. 「アクセス許可の追加」を選択する
3. 「所属する組織で使用しているAPI」を選択する
4. バックエンドとして登録したアプリケーションを選択する
5. 「委任されたアクセス許可」を選択する
6. 「アクセス許可」で「access_as_user」を選択する

#### 同意について

APIのアクセス許可で追加したスコープは、ユーザーまたは管理者による同意が行われて初めて有効になります。

委任されたアクセスの場合、通常はユーザーがサインイン時に同意を行います。
管理者のみが同意できるスコープが含まれる場合は、管理者の同意が必要になります。

同意されたスコープのみが、アクセストークンに含まれます。

#### フロントエンドが取得するトークンの整理

この設定により、フロントエンドは次のトークンを取得できます。

* サインイン時
  * IDトークン
* API呼び出し時
  * Graph API向けアクセストークン
  * バックエンド向けアクセストークン

それぞれのアクセストークンは、呼び出し先のAPIを示す`aud`クレームを持ちます。
フロントエンドは、APIごとに適切なアクセストークンを使い分けて呼び出します。
